I"#<h1 id="1-변수의-기초">1. 변수의 기초</h1>

<h2 id="variable-변수">Variable 변수</h2>

<p>Variable 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
               프로그래밍 언어에서 값을 저장하고 참조하는, 값의 위치를 가리키는 상징적인 이름.
               프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.
               개발자의 직접적인 메모리 주소로의 접근없이 변수를 통해 안전하게 접근 가능하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>

<span class="c1">// result는 변수명, 30(10+20)은 변수값.</span>
</code></pre></div></div>

<p>Assignment 할당 : 변수에 값을 저장하는 것.</p>

<p>Reference 참조 : 변수에 저장된 값을 읽어들이는 것.</p>

<p>변수명은 변수에 저장된 값의 의미를 파악할 수 있는 이름이어야 한다.</p>

<h2 id="identifier-식별자">Identifier 식별자</h2>

<p>Identifier 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름. 
메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자다. 변수, 함수, 클래스 등의 모든 이름이 식별자다.
예를 들어 변수명(식별자)은 변수값이 아니라 변수값이 저장된 메모리 주소를 기억하고 있다. 
식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리에 저장된 값에 접근한다는 의미이다.
즉, 식별자는 메모리 주소에 붙인 이름이다.</p>

<p>식별자는 네이밍규칙을 준수해야하며, Declation선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.</p>

<h2 id="variable-declation-변수선언">Variable declation 변수선언</h2>

<p>Variable declation 변수선언 : 변수를 생성하는 것. 
값을 저장하기 위한 메모리공간을 확보하고 변수이름과 확보된 메모리 공간의 주소를 연결(name binding)하여 값을 저장할 수 있게 준비하는 것.
변수 선언에 의해 확보된 메모리 공간은 확보가 release해제 되기 전까지는 누구도 확보된 메모리공간을 사용할 수 없도록 보호된다.</p>

<p>변수를 선언할때는 var, let, const 키워드를 사용한다.
ES6 이전에는 var는 변수를 선언하는 유일한 keyword키워드(약속된 명령)였고 let, const가 var의 단점을 보완하기 위하여 도입되었다.
ES6에서는 var의 사용을 권장하지 않고 있지만 var가 완전히 폐기된 것은 아니다.</p>

<p>변수선언의 2단계</p>

<p>선언 단계 : 변수이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">tomato</span><span class="p">;</span>

<span class="c1">// tomato라는 변수가 선언되었다. </span>
</code></pre></div></div>
<p>어떠한 값도 할당해주지 않았지만 자바스크립트는 tomato 변수에 암묵적으로 undefined를 할당해 초기화한다.</p>

<p>변수뿐만 아니라 모든 식별자를 사용하기 위해서는 반드시 선언이 필요하다.
선언되지 않은 식별자에 접근하면 RefereneError(참조 에러)가 발생한다.
자바스크립트 엔진은 식별자를 통해 값을 참조하려했지만 등록된 식별자를 찾을 수 없기 때문이다.</p>

<h2 id="변수선언의-실행시점">변수선언의 실행시점</h2>

<p>변수선언은 소스코드가 한줄씩 순차적으로 실행되는 시점(런타임runtime)이 아니라 그 이전 단계에서 먼저 실행된다.
자바스크립트 엔진은 소스코드를 한줄씩 순차적으로 실행하기 전에 먼저 소스코드의 평가 과정을 거치는데 이 단계에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문들을 먼저 실행한다. 그리고 소스코드의 평가과정이 끝나고나서야 모든 선언문들을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">tomato</span><span class="p">;</span>
<span class="c1">// tomato라는 변수가 선언되기전에 사용되었다. </span>
<span class="c1">// ReferenceError가 발생할것처럼 보이지만 undefined가 출력된다.</span>
</code></pre></div></div>
<p>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 Variable hoisting 변수 호이스팅 이라고 한다.</p>

<h2 id="값의-할당">값의 할당</h2>

<p>변수에 값을 assignment 할당할 때는 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">tomato</span><span class="p">;</span> <span class="c1">// 변수 선언</span>
<span class="nx">tomato</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 값의 할당</span>

<span class="kd">var</span> <span class="nx">tomato</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 변수 선언과 값의 할당</span>
</code></pre></div></div>

<p>변수 선언과 값의 할당을 하나의 statement문으로 작성해도 변수 선언은 런타임 이전에 실행되지만 값의 할당은 런타임에 실행된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">)</span> <span class="c1">// undefined</span>

<span class="kd">var</span> <span class="nx">tomato</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 변수 선언과 값의 할당</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">)</span> <span class="c1">//  80</span>
</code></pre></div></div>
<p>첫번째 console.log()에서는 아직 값의 할당이 이루어지기전이기 때문에 런타임 전 변수선언과 함께 암묵적으로 할당된 값인 undefined가 출력되고 두번째 console.log()에서는 값의 할당이 이루어진 후에 실행되었기 때문에 80이 출력된다.
이 경우 메모리에서는 저장되어있던 undefined가 삭제되고 같은 메모리 공간에 할당 값 80을 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 값 80이 할당된다.</p>

<h2 id="값의-재할당과-상수">값의 재할당과 상수</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">tomato</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 변수 선언과 값의 할당</span>
<span class="nx">tomato</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span> <span class="c1">// 값의 재할당</span>
</code></pre></div></div>
<p>var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 변수에 저장된 값을 다른 값으로 변경한다. 하지만 constant 상수는 저장된 값을 변경할 수 없다. 상수는 한번 정해지면 변하지 않는 값이다. 즉, 단 한번만 할당할 수 있는 변수다. 상수는 const 키워드로 선언한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">tomato</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="c1">// 상수 선언과 값의 할당</span>
<span class="nx">tomato</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span> <span class="c1">// 상수의 값을 변경하려하기 때문에 에러가 발생한다.</span>
</code></pre></div></div>

:ET