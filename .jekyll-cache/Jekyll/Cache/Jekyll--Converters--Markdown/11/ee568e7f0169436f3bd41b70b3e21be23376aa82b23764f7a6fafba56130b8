I"<h1 id="1-변수의-기초">1. 변수의 기초</h1>

<h2 id="variable-변수">Variable 변수</h2>

<p>Variable 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
               프로그래밍 언어에서 값을 저장하고 참조하는, 값의 위치를 가리키는 상징적인 이름.
               프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.
               개발자의 직접적인 메모리 주소로의 접근없이 변수를 통해 안전하게 접근 가능하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>

<span class="c1">// result는 변수명, 30(10+20)은 변수값.</span>
</code></pre></div></div>

<p>Assignment 할당 : 변수에 값을 저장하는 것.</p>

<p>Reference 참조 : 변수에 저장된 값을 읽어들이는 것.</p>

<p>변수명은 변수에 저장된 값의 의미를 파악할 수 있는 이름이어야 한다.</p>

<h2 id="identifier-식별자">Identifier 식별자</h2>

<p>Identifier 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름. 
메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자다. 변수, 함수, 클래스 등의 모든 이름이 식별자다.
예를 들어 변수명(식별자)은 변수값이 아니라 변수값이 저장된 메모리 주소를 기억하고 있다. 
식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리에 저장된 값에 접근한다는 의미이다.
즉, 식별자는 메모리 주소에 붙인 이름이다.</p>

<p>식별자는 네이밍규칙을 준수해야하며, Declation선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.</p>

<h2 id="variable-declation-변수선언">Variable declation 변수선언</h2>

<p>Variable declation 변수선언 : 변수를 생성하는 것. 
값을 저장하기 위한 메모리공간을 확보하고 변수이름과 확보된 메모리 공간의 주소를 연결(name binding)하여 값을 저장할 수 있게 준비하는 것.
변수 선언에 의해 확보된 메모리 공간은 확보가 release해제 되기 전까지는 누구도 확보된 메모리공간을 사용할 수 없도록 보호된다.</p>

<p>변수를 선언할때는 var, let, const 키워드를 사용한다.
ES6 이전에는 var는 변수를 선언하는 유일한 keyword키워드(약속된 명령)였고 let, const가 var의 단점을 보완하기 위하여 도입되었다.
ES6에서는 var의 사용을 권장하지 않고 있지만 var가 완전히 폐기된 것은 아니다.</p>

<p>변수선언의 2단계</p>

<p>선언 단계 : 변수이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">tomato</span><span class="p">;</span>

<span class="c1">// tomato라는 변수가 선언되었다. </span>
<span class="c1">// 어떠한 값도 할당해주지 않았지만 </span>
<span class="c1">// 자바스크립트는 tomato 변수에 암묵적으로 undefined를 할당해 초기화한다.</span>
</code></pre></div></div>

<p>변수뿐만 아니라 모든 식별자를 사용하기 위해서는 반드시 선언이 필요하다.
선언되지 않은 식별자에 접근하면 RefereneError(참조 에러)가 발생한다.
자바스크립트 엔진은 식별자를 통해 값을 참조하려했지만 등록된 식별자를 찾을 수 없기 때문이다.</p>

<h2 id="변수선언의-실행시점">변수선언의 실행시점</h2>

<p>변수선언은 소스코드가 한줄씩 순차적으로 실행되는 시점(런타임runtime)이 아니라 그 이전 단계에서 먼저 실행된다.
자바스크립트 엔진은 소스코드를 한줄씩 순차적으로 실행하기 전에 먼저 소스코드의 평가 과정을 거치는데 이 단계에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문들을 먼저 실행한다. 그리고 소스코드의 평가과정이 끝나고나서야 모든 선언문들을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tomato</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">tomato</span><span class="p">;</span>
<span class="c1">// tomato라는 변수가 선언되기전에 사용되었다. </span>
<span class="c1">// ReferenceError가 발생할것처럼 보이지만 undefined가 출력된다.</span>
</code></pre></div></div>
<p>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 Variable hoisting 변수 호이스팅 이라고 한다.</p>

<h2 id="값의-할당">값의 할당</h2>

:ET